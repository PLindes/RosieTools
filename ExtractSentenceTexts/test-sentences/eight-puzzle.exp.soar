#### Test sentences for ROSIE - 
#    Built by the SentencesToSoar tool Fri Sep 04 12:55:27 EDT 2015
#    from file 'eight-puzzle.exp.txt'.
#learn --off
#   Apply initialize-rosie to set up the state.
sp {apply*initialize-rosie*sentence-number
   (state <s> ^name rosie
              ^operator.name initialize-rosie)
-->
   (<s> ^current-sentence-number 4
        ^max-sentence-number 4 # 10
        ^failure-count 0
        ^success-count 0)
}

#   The name of the game is eight-puzzle.
sp {elaborate*state*sentence*the-name-of-the-game-is-eight-puzzle
    :interrupt
   (state <s> ^name comprehension
              ^superstate <ss>
              ^segment <seg>)
   (<ss> ^current-sentence-number 1)
-->
   (<seg> ^input-sentence <first>
          ^current-word <first>
          ^original-sentence <first>)
         # ^expected <S134>)
   (<first> ^spelling |*|
            ^next <w0>
            ^complete-sentence |The name of the game is eight-puzzle.|)
   (<w0> ^spelling |the|
         ^next <w1>)
   (<w1> ^spelling |name|
         ^next <w2>)
   (<w2> ^spelling |of|
         ^next <w3>)
   (<w3> ^spelling |the|
         ^next <w4>)
   (<w4> ^spelling |game|
         ^next <w5>)
   (<w5> ^spelling |is|
         ^next <w6>)
   (<w6> ^spelling |eight-puzzle|
         ^next <w7>)
   (<w7> ^spelling |.|
         ^next nil)
#   (<S134> ^arg1 <S252>
#           ^message-type object-description
#           ^predicate <R10171>)
#   (<S252> ^2 <S253>
#           ^handle of1
#           ^item-type predicate)
#   (<S253> ^2 <G3>
#           ^handle name1)
#   (<G3> ^handle game1
#          ^property <C27>)
#   (<C27> ^handle concept
#           ^type conceptual)
#   (<R10171> #^handle eight-puzzle1
#              ^item-type predicate
#              ^word-structure <N10062>)
#   (<N10062> ^referent <R10171>
#              ^spelling eight-puzzle)
}


#   The name of an action is slide.
sp {elaborate*state*sentence*the-name-of-an-action-is-slide
   (state <s> ^name comprehension
              ^superstate <ss>
              ^segment <seg>)
   (<ss> ^current-sentence-number 2)
-->
   (<seg> ^input-sentence <first>
          ^current-word <first>
          ^original-sentence <first>
          ^expected <S310>)
   (<first> ^spelling |*|
            ^next <w0>
            ^complete-sentence |The name of an action is slide.|)
   (<w0> ^spelling |the|
         ^next <w1>)
   (<w1> ^spelling |name|
         ^next <w2>)
   (<w2> ^spelling |of|
         ^next <w3>)
   (<w3> ^spelling |an|
         ^next <w4>)
   (<w4> ^spelling |action|
         ^next <w5>)
   (<w5> ^spelling |is|
         ^next <w6>)
   (<w6> ^spelling |slide|
         ^next <w7>)
   (<w7> ^spelling |.|
         ^next nil)
   (<S310> ^arg1 <S428>
           ^message-type object-description
           ^predicate <R10292>)
   (<S428> ^2 <S429>
           ^handle of1
           ^item-type predicate)
   (<S429> ^2 <A10025>
           ^handle name1)
   (<A10025> ^handle action
              ^property <C27>)
   (<C27> ^handle concept
           ^type conceptual)
   (<R10292> #^handle slide2
              ^item-type predicate
              ^word-structure <N10101>)
   (<N10101> ^referent <R10292>
              ^spelling slide)
}


#   If a location is next to a clear location but it is not diagonal with the clear location then it is adjacent to the clear location.
sp {elaborate*state*sentence*if-a-location-is-next-to-a-clear-location-but-it-is-not-diagonal-with-the-clear-location-then-it-is-adjacent-to-the-clear-location
   (state <s> ^name comprehension
              ^superstate <ss>
              ^segment <seg>)
   (<ss> ^current-sentence-number 3)
-->
   (<seg> ^input-sentence <first>
          ^current-word <first>
          ^original-sentence <first>
          ^expected <S486>)
   (<first> ^spelling |*|
            ^next <w0>
            ^complete-sentence |If a location is next to a clear location but it is not diagonal with the clear location then it is adjacent to the clear location.|)
   (<w0> ^spelling |if|
         ^next <w1>)
   (<w1> ^spelling |a|
         ^next <w2>)
   (<w2> ^spelling |location|
         ^next <w3>)
   (<w3> ^spelling |is|
         ^next <w4>)
   (<w4> ^spelling |next|
         ^next <w5>)
   (<w5> ^spelling |to|
         ^next <w6>)
   (<w6> ^spelling |a|
         ^next <w7>)
   (<w7> ^spelling |clear|
         ^next <w8>)
   (<w8> ^spelling |location|
         ^next <w9>)
   (<w9> ^spelling |but|
         ^next <w10>)
   (<w10> ^spelling |it|
         ^next <w11>)
   (<w11> ^spelling |is|
         ^next <w12>)
   (<w12> ^spelling |not|
         ^next <w13>)
   (<w13> ^spelling |diagonal|
         ^next <w14>)
   (<w14> ^spelling |with|
         ^next <w15>)
   (<w15> ^spelling |the|
         ^next <w16>)
   (<w16> ^spelling |clear|
         ^next <w17>)
   (<w17> ^spelling |location|
         ^next <w18>)
   (<w18> ^spelling |then|
         ^next <w19>)
   (<w19> ^spelling |it|
         ^next <w20>)
   (<w20> ^spelling |is|
         ^next <w21>)
   (<w21> ^spelling |adjacent|
         ^next <w22>)
   (<w22> ^spelling |to|
         ^next <w23>)
   (<w23> ^spelling |the|
         ^next <w24>)
   (<w24> ^spelling |clear|
         ^next <w25>)
   (<w25> ^spelling |location|
         ^next <w26>)
   (<w26> ^spelling |.|
         ^next nil)
   (<S486> ^if-subclause <S709>
           ^message-type conditional
           ^then-subclause <S980>)
   (<S709> ^subclause <S784>
           ^subclause <S596>)
   (<S784> ^arg1 <P90129>
           ^modifier <N10004>
           ^predicate <S901>)
   (<N10004> ^handle negation)
   (<S901> ^2 <P90150>
           ^handle diagonal-with1
           ^item-type predicate)
   (<S596> ^arg1 <P90129>
           ^predicate <S696>)
   (<S696> ^2 <P90150>
           ^handle next-to1
           ^item-type predicate)
   (<S980> ^arg1 <P90129>
           ^predicate <S1080>)
   (<P90129> #^handle new-object-id3
             ^item-type location
             ^predicates <P90130>
             ^predicates-copied true)
   (<P90130> ^category location
             ^dialog-object true)
   (<S1080> ^2 <P90150>
            ^handle adjacent
            ^item-type predicate)
   (<P90150> #^handle new-object-id4
             ^item-type location
             ^predicates <P90151>
             ^predicates-copied true)
   (<P90151> ^category location
             ^dialog-object true
             ^property clear)
}


#   If a block is on a location that is adjacent to a clear location then you can move the block onto the clear location.
sp {elaborate*state*sentence*if-a-block-is-on-a-location-that-is-adjacent-to-a-clear-location-then-you-can-move-the-block-onto-the-clear-location
   (state <s> ^name comprehension
              ^superstate <ss>
              ^segment <seg>)
   (<ss> ^current-sentence-number 4)
-->
   (<seg> ^input-sentence <first>
          ^current-word <first>
          ^original-sentence <first>
          ^expected <S1107>)
   (<first> ^spelling |*|
            ^next <w0>
            ^complete-sentence |If a block is on a location that is adjacent to a clear location then you can move the block onto the clear location.|)
   (<w0> ^spelling |if|
         ^next <w1>)
   (<w1> ^spelling |a|
         ^next <w2>)
   (<w2> ^spelling |block|
         ^next <w3>)
   (<w3> ^spelling |is|
         ^next <w4>)
   (<w4> ^spelling |on|
         ^next <w5>)
   (<w5> ^spelling |a|
         ^next <w6>)
   (<w6> ^spelling |location|
         ^next <w7>)
   (<w7> ^spelling |that|
         ^next <w8>)
   (<w8> ^spelling |is|
         ^next <w9>)
   (<w9> ^spelling |adjacent|
         ^next <w10>)
   (<w10> ^spelling |to|
         ^next <w11>)
   (<w11> ^spelling |a|
         ^next <w12>)
   (<w12> ^spelling |clear|
         ^next <w13>)
   (<w13> ^spelling |location|
         ^next <w14>)
   (<w14> ^spelling |then|
         ^next <w15>)
   (<w15> ^spelling |you|
         ^next <w16>)
   (<w16> ^spelling |can|
         ^next <w17>)
   (<w17> ^spelling |move|
         ^next <w18>)
   (<w18> ^spelling |the|
         ^next <w19>)
   (<w19> ^spelling |block|
         ^next <w20>)
   (<w20> ^spelling |onto|
         ^next <w21>)
   (<w21> ^spelling |the|
         ^next <w22>)
   (<w22> ^spelling |clear|
         ^next <w23>)
   (<w23> ^spelling |location|
         ^next <w24>)
   (<w24> ^spelling |.|
         ^next nil)
   (<S1107> ^if-subclause <S1217>
            ^message-type conditional
            ^then-subclause <S1692>)
   (<S1217> ^arg1 <P90253>
            ^predicate <S1427>)
   (<P90253> #^handle new-object-id5
             ^item-type block
             ^predicates <P90254>
             ^predicates-copied true)
   (<P90254> ^category block
             ^dialog-object true)
   (<S1427> ^2 <P90352>
            ^handle on1
            ^item-type predicate)
   (<P90352> #^handle new-object-id8
             ^item-type location
             ^predicates <P90353>
             ^predicates-copied true
             ^relation <S1417>)
   (<P90353> ^category location
             ^dialog-object true)
   (<S1417> ^2 <P90290>
            ^handle adjacent)
   (<P90290> #^handle new-object-id6
             ^item-type location
             ^predicates <P90291>
             ^predicates-copied true)
   (<P90291> ^category location
             ^dialog-object true
             ^property clear)
   (<S1692> ^action <A1008>
            ^action-modifier <C52>
            ^agent <R10042>
            ^arg1 <P90393>
            ^arg2 <S1675>)
   (<A1008> ^handle move1
             ^item-type action)
   (<C52> ^handle can)
   (<R10042> ^arm <A10080>
             ^handle rosie
             ^item-type object
             ^predicates <P90070>)
   (<A10080> ^action wait)
   (<P90070> ^handle rosie)
   (<P90393> #^handle new-object-id9
             ^item-type block
             ^predicates <P90394>
             ^predicates-copied true)
   (<P90394> ^category block
             ^dialog-object true
             ^visibility not-visible)
   (<S1675> ^2 <P90427>
            ^handle on1
            ^item-type predicate)
   (<P90427> #^handle new-object-id10
             ^item-type location
             ^predicates <P90428>
             ^predicates-copied true)
   (<P90428> ^category location
             ^dialog-object true
             ^property clear
             ^visibility not-visible)
}

#   If the color of a location is equal to the color of the block that is on the location then the color is matched.
sp {elaborate*state*sentence*if-the-color-of-a-location-is-equal-to-the-color-of-the-block-that-is-on-the-location-then-the-color-is-matched
   (state <s> ^name comprehension
              ^superstate <ss>
              ^segment <seg>)
   (<ss> ^current-sentence-number 5)
-->
   (<seg> ^input-sentence <first>
          ^current-word <first>
          ^original-sentence <first>
          ^expected <S1715>)
   (<first> ^spelling |*|
            ^next <w0>
            ^complete-sentence |If the color of a location is equal to the color of the block that is on the location then the color is matched.|)
   (<w0> ^spelling |if|
         ^next <w1>)
   (<w1> ^spelling |the|
         ^next <w2>)
   (<w2> ^spelling |color|
         ^next <w3>)
   (<w3> ^spelling |of|
         ^next <w4>)
   (<w4> ^spelling |a|
         ^next <w5>)
   (<w5> ^spelling |location|
         ^next <w6>)
   (<w6> ^spelling |is|
         ^next <w7>)
   (<w7> ^spelling |equal|
         ^next <w8>)
   (<w8> ^spelling |to|
         ^next <w9>)
   (<w9> ^spelling |the|
         ^next <w10>)
   (<w10> ^spelling |color|
         ^next <w11>)
   (<w11> ^spelling |of|
         ^next <w12>)
   (<w12> ^spelling |the|
         ^next <w13>)
   (<w13> ^spelling |block|
         ^next <w14>)
   (<w14> ^spelling |that|
         ^next <w15>)
   (<w15> ^spelling |is|
         ^next <w16>)
   (<w16> ^spelling |on|
         ^next <w17>)
   (<w17> ^spelling |the|
         ^next <w18>)
   (<w18> ^spelling |location|
         ^next <w19>)
   (<w19> ^spelling |then|
         ^next <w20>)
   (<w20> ^spelling |the|
         ^next <w21>)
   (<w21> ^spelling |color|
         ^next <w22>)
   (<w22> ^spelling |is|
         ^next <w23>)
   (<w23> ^spelling |matched|
         ^next <w24>)
   (<w24> ^spelling |.|
         ^next nil)
   (<S1715> ^if-subclause <S1877>
            ^message-type conditional
            ^then-subclause <S2237>)
   (<S1877> ^arg1 <S1878>
            ^predicate <S2133>)
   (<S1878> ^2 <S1879>
            ^handle of1
            ^item-type predicate)
   (<S1879> ^2 <P7002>
            ^handle color)
   (<P7002> ^handle location
             ^property <P7000>)
   (<P7000> ^handle category
             ^item-type property
             ^type visual)
   (<S2133> ^2 <C28>
            ^handle equal
            ^item-type predicate)
   (<S2237> ^arg1 <C28>
            ^predicate <M3>)
   (<C28> ^handle color
           ^property <C27>)
   (<C27> ^handle concept
           ^type conceptual)
   (<M3> ^handle matched
          ^item-type predicate
          ^property <C12>)
   (<C12> ^handle property
           ^type visual)
}


#   If the color of a location is equal to the color of the block that is on the location then the location is matched.
sp {elaborate*state*sentence*if-the-color-of-a-location-is-equal-to-the-color-of-the-block-that-is-on-the-location-then-the-location-is-matched
   (state <s> ^name comprehension
              ^superstate <ss>
              ^segment <seg>)
   (<ss> ^current-sentence-number 6)
-->
   (<seg> ^input-sentence <first>
          ^current-word <first>
          ^original-sentence <first>
          ^expected <S2298>)
   (<first> ^spelling |*|
            ^next <w0>
            ^complete-sentence |If the color of a location is equal to the color of the red block then the location is matched.|)
   (<w0> ^spelling |if|
         ^next <w1>)
   (<w1> ^spelling |the|
         ^next <w2>)
   (<w2> ^spelling |color|
         ^next <w3>)
   (<w3> ^spelling |of|
         ^next <w4>)
   (<w4> ^spelling |a|
         ^next <w5>)
   (<w5> ^spelling |location|
         ^next <w6>)
   (<w6> ^spelling |is|
         ^next <w7>)
   (<w7> ^spelling |equal|
         ^next <w8>)
   (<w8> ^spelling |to|
         ^next <w9>)
   (<w9> ^spelling |the|
         ^next <w10>)
   (<w10> ^spelling |color|
         ^next <w11>)
   (<w11> ^spelling |of|
         ^next <w12>)
   (<w12> ^spelling |the|
         ^next <w122>)
   (<w122> ^spelling |red|
           ^next <w13>)
   (<w13> ^spelling |block|
#         ^next <w14>)
#   (<w14> ^spelling |that|
#         ^next <w15>)
#   (<w15> ^spelling |is|
#         ^next <w16>)
#   (<w16> ^spelling |on|
#         ^next <w17>)
#   (<w17> ^spelling |the|
#         ^next <w18>)
#   (<w18> ^spelling |location|
         ^next <w19>)
   (<w19> ^spelling |then|
         ^next <w20>)
   (<w20> ^spelling |the|
         ^next <w21>)
   (<w21> ^spelling |location|
         ^next <w22>)
   (<w22> ^spelling |is|
         ^next <w23>)
   (<w23> ^spelling |matched|
         ^next <w24>)
   (<w24> ^spelling |.|
         ^next nil)
   (<S2298> ^if-subclause <S2460>
            ^message-type conditional
            ^then-subclause <S2824>)
   (<S2460> ^arg1 <S2461>
            ^predicate <S2716>)
   (<S2461> ^2 <S2462>
            ^handle of1
            ^item-type predicate)
   (<S2462> ^2 <P7002>
            ^handle color)
   (<P7002> ^handle location
             ^property <P7000>)
   (<P7000> ^handle category
             ^item-type property
             ^type visual)
   (<S2716> ^2 <C28>
            ^handle equal
            ^item-type predicate)
   (<C28> ^handle color
           ^property <C27>)
   (<C27> ^handle concept
           ^type conceptual)
   (<S2824> ^arg1 <P90951>
            ^predicate <M3>)
   (<P90951> #^handle new-object-id19
             ^item-type location
             ^predicates <P90952>
             ^predicates-copied true)
   (<P90952> ^category location
             ^dialog-object true
             ^visibility not-visible)
   (<M3> ^handle matched
          ^item-type predicate
          ^property <C12>)
   (<C12> ^handle property
           ^type visual)
}

#   If the color of a location is the color of the block that is on the location then the location is matched.
sp {elaborate*state*sentence*if-the-color-of-a-location-is-the-color-of-the-block-that-is-on-the-location-then-the-location-is-matched
   (state <s> ^name comprehension
              ^superstate <ss>
              ^segment <seg>)
   (<ss> ^current-sentence-number 7)
-->
   (<seg> ^input-sentence <first>
          ^current-word <first>
          ^original-sentence <first>
          ^expected <S2885>)
   (<first> ^spelling |*|
            ^next <w0>
            ^complete-sentence |If the color of a location is the color of the block that is on the location then the location is matched.|)
   (<w0> ^spelling |if|
         ^next <w1>)
   (<w1> ^spelling |the|
         ^next <w2>)
   (<w2> ^spelling |color|
         ^next <w3>)
   (<w3> ^spelling |of|
         ^next <w4>)
   (<w4> ^spelling |a|
         ^next <w5>)
   (<w5> ^spelling |location|
         ^next <w6>)
   (<w6> ^spelling |is|
         ^next <w7>)
   (<w7> ^spelling |the|
         ^next <w8>)
   (<w8> ^spelling |color|
         ^next <w9>)
   (<w9> ^spelling |of|
         ^next <w10>)
   (<w10> ^spelling |the|
         ^next <w11>)
   (<w11> ^spelling |block|
         ^next <w12>)
   (<w12> ^spelling |that|
         ^next <w13>)
   (<w13> ^spelling |is|
         ^next <w14>)
   (<w14> ^spelling |on|
         ^next <w15>)
   (<w15> ^spelling |the|
         ^next <w16>)
   (<w16> ^spelling |location|
         ^next <w17>)
   (<w17> ^spelling |then|
         ^next <w18>)
   (<w18> ^spelling |the|
         ^next <w19>)
   (<w19> ^spelling |location|
         ^next <w20>)
   (<w20> ^spelling |is|
         ^next <w21>)
   (<w21> ^spelling |matched|
         ^next <w22>)
   (<w22> ^spelling |.|
         ^next nil)
   (<S2885> ^if-subclause <S3047>
            ^message-type conditional
            ^then-subclause <S3266>)
   (<S3047> ^arg1 <S3048>
            ^predicate <S3157>)
   (<S3048> ^2 <S3049>
            ^handle of1
            ^item-type predicate)
   (<S3049> ^2 <P7002>
            ^handle color)
   (<P7002> ^handle location
             ^property <P7000>)
   (<P7000> ^handle category
             ^item-type property
             ^type visual)
   (<S3157> ^2 <S3158>
            ^handle of1
            ^item-type predicate)
   (<S3158> ^2 <P7001>
            ^handle color)
   (<P7001> ^handle block
             ^property <P7000>)
   (<S3266> ^arg1 <P91078>
            ^predicate <M3>)
   (<P91078> #^handle new-object-id22
             ^item-type location
             ^predicates <P91079>
             ^predicates-copied true)
   (<P91079> ^category location
             ^dialog-object true
             ^visibility not-visible)
   (<M3> ^handle matched
          ^item-type predicate
          ^property <C12>)
   (<C12> ^handle property
           ^type visual)
}


#   The goal is that there are eight matched locations.
sp {elaborate*state*sentence*the-goal-is-that-there-are-eight-matched-locations
   (state <s> ^name comprehension
              ^superstate <ss>
              ^segment <seg>)
   (<ss> ^current-sentence-number 8)
-->
   (<seg> ^input-sentence <first>
          ^current-word <first>
          ^original-sentence <first>
          ^expected <S3327>)
   (<first> ^spelling |*|
            ^next <w0>
            ^complete-sentence |The goal is that there are eight matched locations.|)
   (<w0> ^spelling |the|
         ^next <w1>)
   (<w1> ^spelling |goal|
         ^next <w2>)
   (<w2> ^spelling |is|
         ^next <w3>)
   (<w3> ^spelling |that|
         ^next <w4>)
   (<w4> ^spelling |there|
         ^next <w5>)
   (<w5> ^spelling |are|
         ^next <w6>)
   (<w6> ^spelling |eight|
         ^next <w7>)
   (<w7> ^spelling |matched|
         ^next <w8>)
   (<w8> ^spelling |locations|
         ^next <w9>)
   (<w9> ^spelling |.|
         ^next nil)
   (<S3327> ^arg1 <G4>
            ^message-type object-description
            ^subclause <S3401>)
   (<G4> ^handle goal
          ^property <C27>)
   (<C27> ^handle concept
           ^type conceptual)
   (<S3401> ^predicate <P90132>)
    (<P90132> #^handle new-object-id1 
              ^item-type location ^predicates <P90133>
           ^predicates-copied true)
      (<P90133> ^category location ^dialog-object true ^multiple true ^number 8
             ^property matched ^visibility not-visible)
}


#   The goal is that eight locations are matched.
sp {elaborate*state*sentence*the-goal-is-that-eight-locations-are-matched
   (state <s> ^name comprehension
              ^superstate <ss>
              ^segment <seg>)
   (<ss> ^current-sentence-number 9)
-->
   (<seg> ^input-sentence <first>
          ^current-word <first>
          ^original-sentence <first>
          ^expected <S3559>)
   (<first> ^spelling |*|
            ^next <w0>
            ^complete-sentence |The goal is that eight locations are matched.|)
   (<w0> ^spelling |the|
         ^next <w1>)
   (<w1> ^spelling |goal|
         ^next <w2>)
   (<w2> ^spelling |is|
         ^next <w3>)
   (<w3> ^spelling |that|
         ^next <w4>)
   (<w4> ^spelling |eight|
         ^next <w5>)
   (<w5> ^spelling |locations|
         ^next <w6>)
   (<w6> ^spelling |are|
         ^next <w7>)
   (<w7> ^spelling |matched|
         ^next <w8>)
   (<w8> ^spelling |.|
         ^next nil)
   (<S3559> ^arg1 <G4>
            ^message-type object-description
            ^subclause <S3633>)
   (<G4> ^handle goal
          ^property <C27>)
   (<C27> ^handle concept
           ^type conceptual)
   (<S3633> ^arg1 <P91156>
            ^predicate <M3>)
   (<P91156> #^handle new-object-id23
             ^item-type location
             ^predicates <P91157>
             ^predicates-copied true)
   (<P91157> ^category location
             ^dialog-object true
             ^multiple true
             ^number 8
             ^visibility not-visible)
   (<M3> ^handle matched
          ^item-type predicate
          ^property <C12>)
   (<C12> ^handle property
           ^type visual)
}


#   The goal is that the number of the matched locations is eight.
sp {elaborate*state*sentence*the-goal-is-that-the-number-of-the-matched-locations-is-eight
   (state <s> ^name comprehension
              ^superstate <ss>
              ^segment <seg>)
   (<ss> ^current-sentence-number 10)
-->
   (<seg> ^input-sentence <first>
          ^current-word <first>
          ^original-sentence <first>
          ^expected <S3790>)
   (<first> ^spelling |*|
            ^next <w0>
            ^complete-sentence |The goal is that the number of the matched locations is eight.|)
   (<w0> ^spelling |the|
         ^next <w1>)
   (<w1> ^spelling |goal|
         ^next <w2>)
   (<w2> ^spelling |is|
         ^next <w3>)
   (<w3> ^spelling |that|
         ^next <w4>)
   (<w4> ^spelling |the|
         ^next <w5>)
   (<w5> ^spelling |number|
         ^next <w6>)
   (<w6> ^spelling |of|
         ^next <w7>)
   (<w7> ^spelling |the|
         ^next <w8>)
   (<w8> ^spelling |matched|
         ^next <w9>)
   (<w9> ^spelling |locations|
         ^next <w10>)
   (<w10> ^spelling |is|
         ^next <w11>)
   (<w11> ^spelling |eight|
         ^next <w12>)
   (<w12> ^spelling |.|
         ^next nil)
   (<S3790> ^arg1 <G4>
            ^message-type object-description
            ^subclause <S3864>)
   (<G4> ^handle goal
          ^property <C27>)
   (<C27> ^handle concept
           ^type conceptual)
   (<S3864> ^arg1 <S4034>
            ^predicate <P11018>)
   (<S4034> ^2 <S4035>
            ^handle of1
            ^item-type predicate)
   (<S4035> ^2 <P7005>
            ^handle number1)
   (<P7005> ^handle location
             ^multiple true
             ^property <P7000>)
   (<P7000> ^handle category
             ^item-type property
             ^type visual)
   (<P11018> ^handle 8
              ^item-type predicate
              ^property <P11000>)
   (<P11000> ^handle number
              ^item-type property
              ^type number)
}


